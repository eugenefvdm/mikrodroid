/* 
 * (c) Copyright 2011-2012 Snowball
 * 
 * FTP routines based on http://hoang17.com/posts/android/android-how-to-upload-a-file-via-ftp
 * 
 */

package com.mikrodroid.router;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;

import android.os.Environment;
import android.util.Log;

/**
 * Import a list of known commands from the router. The list is generated by
 * doing an /export file=commands from the router. This creates a plain text commands.rsc file
 * which is imported using FTP to the Android phone. Android scans the file
 * and extracts all pertinent commands out of it by looking for '/'
 * Additional commands is added manually at the end of the import.
 * 
 */
public class MikrotikCommandSet {

	private static final String TAG = "MikrotikCommandSet";
	
	/**
	 * Total number of menus that starts with a "/"
	 */
	private static int numMenus = 0;
	
	/**
	 * allMenus assigned locally to global Main.menuList in constructor
	 */
	private MenuList menuList;

	public MikrotikCommandSet() {
		menuList = Main.menuList;
	}
	
	/**
	 * Read a raw file on the Android SD card that contains a list of MikroTik commands and process the lines read
	 * 
	 * TODO Reading the file and scrolling over the menu should be split
	 * TODO More error checking when reading the file
	 * 
	 * @param fileName
	 */
	public void importCommands(String fileName) {
		int total = 0;
		try {			 
			   File f = new File(Environment.getExternalStorageDirectory()+"/" + fileName);
			   FileInputStream fileIS = new FileInputStream(f);			 
			   BufferedReader buf = new BufferedReader(new InputStreamReader(fileIS));			 
			   String lineInput = new String();			 			 
			   while((lineInput = buf.readLine())!= null){			 
			      total = checkIfMenu(lineInput);
			   }			   			   
			   // Output how many were read
			   Log.d(TAG, String.valueOf(total) + " lines read from configuration file");
			   
			   // Add some manual menus
			   // Test to see how to activate multi line
			   
			   //addMenuFromLineExport("/user active");
			   
			   MenuObject menu1 = new MenuObject();								
			   menu1.setPath("/user");
			   menu1.setName("active");				
			   menu1.setFullPath("/user active");
			   menu1.setMultiLine(true);
			   menuList.add(menu1);
			   
			   MenuObject menu2 = new MenuObject();								
			   menu2.setPath("/interface");
			   menu2.setName("print");				
			   menu2.setFullPath("/interface print");
			   menu2.setMultiLine(true);
			   menuList.add(menu2);
			   
			   MenuObject menu3 = new MenuObject();								
			   menu3.setPath("/user");
			   menu3.setName("print");				
			   menu3.setFullPath("/user print");
			   menu3.setMultiLine(true);
			   menuList.add(menu3);
			   
			   addMenuFromLineExport("/ip hotspot active");
			   
			   MenuObject menu4 = new MenuObject();								
			   menu4.setPath("/ip hotspot active");
			   menu4.setName("print");				
			   menu4.setFullPath("/ip hotspot active print");			   
			   menu4.setMultiLine(true);
			   menu4.setProplist("user,address,uptime");
			   menuList.add(menu4);
			   
			  
			   
//			   MenuObject menu2 = new MenuObject();								
//			   menu2.setPath("/");
//			   menu2.setName("user");				
//			   menu2.setFullPath("/user");
//			   menu2.setMultiLine(true);
//			   menuList.add(menu2);
		
			   setParents();
			   setFriendlyNames();
			   
			   MenuObject ipaddress = new MenuObject();
			   ipaddress = this.findMenu("/ip address");
			   // TODO Add null handling if ipaddress does not return
			   ipaddress.setMultiLine(true);
			   
			} catch (FileNotFoundException e) {			 
			   e.printStackTrace();			 
			} catch (IOException e){			 
			   e.printStackTrace();			 
			}

	}

	/**
	 * Based on raw output from a MikroTik export command, see if the line contains a "/" and if so add a new menu
	 * 
	 * @param lineInput
	 */
	private int checkIfMenu(String lineInput) {		
		if (lineInput.startsWith("/")) {
			addMenuFromLineExport(lineInput);
			numMenus = numMenus +1;			
		}		
		return numMenus;
	}

	/**
	 * Iterate over a command and add menus until there are no menus left
	 * 
	 * E.g.: /ip hotspot host print
	 * 
	 * @param lineInput
	 */
	private void addMenuFromLineExport(String lineInput) {		
		int lastSpace = lineInput.lastIndexOf(" ");		
		while (lastSpace != -1) {
			String menuPath = lineInput.substring(0, lastSpace);
			String menuName = lineInput.substring(lastSpace + 1, lineInput.length());			
			if (menuList.checkMenuExists(menuPath, menuName) == false) {
				MenuObject menu = new MenuObject();								
				menu.setPath(menuPath);
				menu.setName(menuName);				
				menu.setFullPath(menuPath + " " + menuName);
				//Log.v(TAG, "Adding full path " + menu.getFullPath());
				menuList.add(menu);
				
			}
			lineInput = menuPath;
			lastSpace = lineInput.lastIndexOf(" ");
		}		
		String menuName = lineInput.substring(1, lineInput.length());		
		addRootMenu(menuName);		
	}

	private void addRootMenu(String menuName) {
		if (menuList.checkMenuExists("/", menuName) == false) {
			MenuObject menu = new MenuObject();
			menu.setPath("/");
			menu.setName(menuName);		
			menu.setFullPath("/" + menuName);
			menuList.add(menu);		
			
////			 Add print menu everywhere
//			MenuObject menu2 = new MenuObject();								
//			menu2.setPath("/" + menuName);
//			menu2.setName("print");				
//			menu2.setFullPath("/" + menuName + " " + "print");
//			menu2.setMultiLine(false);
//			menuList.add(menu2);
			
		} else {			
		}
	}
	
	/**
	 * Iterate over menus and if it's not a root menu, and the menu has not been assigned, assign a parent
	 */
	public void setParents() {
		int numChildrenWithParents = 0;
		Log.d(TAG, "There are " + String.valueOf(menuList.size()) + " menus");		
		for (MenuObject child : menuList) {
			if (!child.path.equals("/") && child.getParent() == null) {
				child.setParent(findParent(child));
				numChildrenWithParents = numChildrenWithParents + 1;
			}
		}
		Log.d(TAG, "Finished assigning " + String.valueOf(numChildrenWithParents) + " children with parents");
	}
	
	public MenuObject findParent(MenuObject child) {
		for (MenuObject m : menuList) {
			if (child.path.equals(m.getFullPath())) {
				return m;
			}
		}
		Log.e(TAG, "Fatal error: Could not find a parent for " + child.fullPath);
		// This should never happen
		return null;
	}
	
	public MenuObject findMenu(String path) {
		for (MenuObject m : menuList) {
			if (m.getFullPath().equals(path)) {
				return m;
			}
		}
		Log.e(TAG, "Could not find menu `" + path + "` in findMenu");
		// This should never happen
		return null;
	}
	
	/**
	 * Capitalise words
	 * 
	 * TODO: Many words are hyphenated perhaps we could build something in the MenuObject that takes care of this
	 */
	private void setFriendlyNames() {
		setFriendlyName("aaa", "AAA");
		setFriendlyName("access-list", "Access-List");
		setFriendlyName("bfd", "BFD");		
		setFriendlyName("bgp", "BGP");
		setFriendlyName("dhcp-client", "DHCP-Client");
		setFriendlyName("dhcp-server", "DHCP-Server");		
		setFriendlyName("dhcp-relay", "DHCP-Relay");
		setFriendlyName("dns", "DNS");
		setFriendlyName("ip", "IP");
		setFriendlyName("ipsec", "IPsec");
		setFriendlyName("ip-binding", "IP-Binding");
		setFriendlyName("manual-tx-power-table", "Manual-Tx-Power-Table");
		setFriendlyName("mme", "MME");
		setFriendlyName("mpls", "MPLS");
		setFriendlyName("nat", "NAT");
		setFriendlyName("ntp", "NTP");
		setFriendlyName("nv2", "NV2");
		setFriendlyName("ospf", "OSPF");
		setFriendlyName("ppp", "PPP");
		setFriendlyName("pppoe-client", "PPPoE-Client");
		setFriendlyName("radius", "RADIUS");
		setFriendlyName("registration-table", "Registration-Table");
		setFriendlyName("rip", "RIP");
		setFriendlyName("routerboard", "RouterBOARD");
		setFriendlyName("security-profiles", "Security-Profiles");
		setFriendlyName("service-port", "Service-Port");
		setFriendlyName("snmp", "SNMP");
		setFriendlyName("ssh", "SSH");
		setFriendlyName("traffic-flow", "Traffic-Flow");
		setFriendlyName("upnp", "UPnP");
		setFriendlyName("walled-garden", "Walled-Garden");
		setFriendlyName("wds", "WDS");		
		setFriendlyName("web-access", "Web-Access");
	}
	
	/**
	 * Find a menu based on it's name and then set the friendly name field variable
	 * @param fullPath
	 * @param name
	 */
	private void setFriendlyName(String fullPath, String name) {
		for (MenuObject m : menuList) {
			if (m.getName().equals(fullPath)) {
				m.setFriendlyName(name);
			}
		}
	}
	
	public MenuList getMenus() {
		return menuList;
	}

}